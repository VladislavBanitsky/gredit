<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Сегментация изображения</title>
  <style>
    canvas {
      border: 1px solid black;
    }
  </style>
</head>
<body>
  <input type="file" id="imageInput" />
  <canvas id="canvas"></canvas>

  <script>
    document.getElementById('imageInput').addEventListener('change', function(event) {
      const file = event.target.files[0];
      const img = new Image();
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        segmentImage();
      };

      img.src = URL.createObjectURL(file);
    });

    function segmentImage() {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const pixels = imageData.data;
      const width = canvas.width;
      const height = canvas.height;

      // Массив для хранения информации о сегментах
      const segments = [];
      const visited = new Array(width * height).fill(false);

      // Функция для поиска соседей (4 направления)
      function getNeighbors(x, y) {
        const neighbors = [];
        if (x > 0) neighbors.push([x - 1, y]);
        if (x < width - 1) neighbors.push([x + 1, y]);
        if (y > 0) neighbors.push([x, y - 1]);
        if (y < height - 1) neighbors.push([x, y + 1]);
        return neighbors;
      }

      // Преобразование пикселей в чёрно-белое изображение (градации серого)
      function getGrayValue(x, y) {
        const index = (y * width + x) * 4;
        const r = pixels[index];
        const g = pixels[index + 1];
        const b = pixels[index + 2];
        return (r + g + b) / 3;
      }

      // Поиск сегментов с помощью DFS
      function floodFill(x, y, segmentId) {
        const stack = [[x, y]];
        const grayValue = getGrayValue(x, y);
        const segment = [];
        visited[y * width + x] = true;

        while (stack.length > 0) {
          const [cx, cy] = stack.pop();
          segment.push([cx, cy]);

          getNeighbors(cx, cy).forEach(([nx, ny]) => {
            const index = ny * width + nx;
            if (!visited[index] && Math.abs(getGrayValue(nx, ny) - grayValue) < 20) {
              visited[index] = true;
              stack.push([nx, ny]);
            }
          });
        }

        segments.push({ id: segmentId, pixels: segment, color: getRandomColor() });
      }

      // Генерация случайного цвета RGB
      function getRandomColor() {
        return {
          r: Math.floor(Math.random() * 256),
          g: Math.floor(Math.random() * 256),
          b: Math.floor(Math.random() * 256)
        };
      }

      // Сегментация изображения
      let segmentId = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const index = y * width + x;
          if (!visited[index]) {
            floodFill(x, y, segmentId);
            segmentId++;
          }
        }
      }

      // Перерисовка изображения с окрашенными сегментами
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      segments.forEach(segment => {
        segment.pixels.forEach(([x, y]) => {
          const index = (y * width + x) * 4;
          pixels[index] = segment.color.r;
          pixels[index + 1] = segment.color.g;
          pixels[index + 2] = segment.color.b;
          pixels[index + 3] = 255; // Полная непрозрачность
        });
      });

      ctx.putImageData(imageData, 0, 0);
    }
  </script>
</body>
</html>